// utils/schemas/contactEmailSchema.js
// Validation Yup pour le formulaire de contact - Production Ready
// Adaptée aux besoins spécifiques du site Benew

import * as yup from 'yup';

// =============================
// CONFIGURATION DE VALIDATION
// =============================

const CONTACT_VALIDATION_CONFIG = {
  // Limites de champs pour prévenir l'abus
  name: {
    minLength: 2,
    maxLength: 100,
  },
  email: {
    maxLength: 254, // RFC 5321 limit
  },
  subject: {
    minLength: 3,
    maxLength: 200,
  },
  message: {
    minLength: 10,
    maxLength: 2000, // Limite raisonnable pour éviter le spam
  },

  // Patterns de sécurité
  security: {
    // Détecter les tentatives de spam
    spamPatterns: [
      /viagra|cialis|pharmacy|casino|lottery|winner|congratulations/i,
      /click here|visit now|urgent|limited time|act now/i,
      /\$\$\$|money back|100% free|risk free/i,
      /http[s]?:\/\/[^\s]{10,}/gi, // URLs suspectes longues
    ],

    // Patterns d'injection
    injectionPatterns: [
      /<script|<iframe|<object|<embed/i,
      /javascript:|data:|vbscript:/i,
      /on\w+\s*=/i, // Event handlers HTML
      /(\{|\[).*(\}|\])/s, // JSON structures suspectes
    ],

    // Détection de bots
    botPatterns: [
      /test@test\.com|admin@admin\.com|noreply@/i,
      /^.{1,2}@|@.{1,2}$/, // Emails trop courts
      /(.)\1{5,}/, // Répétition excessive de caractères
    ],
  },
};

// =============================
// FONCTIONS DE VALIDATION CUSTOM
// =============================

/**
 * Valide qu'un nom semble réaliste (pas de bot/spam)
 */
function validateRealName(value) {
  if (!value) return false;

  const name = value.trim();

  // Trop court ou trop long
  if (name.length < 2 || name.length > 100) return false;

  // Que des caractères spéciaux
  if (!/[a-zA-ZÀ-ÿ]/.test(name)) return false;

  // Répétition excessive
  if (/(.)\1{4,}/.test(name)) return false;

  // Patterns de spam courants
  const spamNames = [
    /^test\d*$/i,
    /^user\d*$/i,
    /^admin\d*$/i,
    /^guest\d*$/i,
    /^spam|fake|bot/i,
  ];

  return !spamNames.some((pattern) => pattern.test(name));
}

/**
 * Valide un email avec des règles strictes
 */
function validateBusinessEmail(value) {
  if (!value) return false;

  const email = value.toLowerCase().trim();

  // RFC 5322 regex simplifié mais robuste
  const emailRegex =
    /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;

  if (!emailRegex.test(email)) return false;

  // Domaines temporaires/jetables courants
  const disposableDomainsPatterns = [
    /10minutemail|tempmail|guerrillamail|mailinator/i,
    /yopmail|throwaway|disposable|temporary/i,
    /fakeinbox|spamgourmet|sharklasers/i,
  ];

  const domain = email.split('@')[1];
  if (disposableDomainsPatterns.some((pattern) => pattern.test(domain))) {
    return false;
  }

  // Vérifier les patterns de bots
  return !CONTACT_VALIDATION_CONFIG.security.botPatterns.some((pattern) =>
    pattern.test(email),
  );
}

/**
 * Valide le contenu contre le spam et les injections
 */
function validateContentSecurity(value, fieldName) {
  if (!value) return true; // Validation optionnelle

  const content = value.toString();

  // Vérifier les patterns de spam
  const hasSpam = CONTACT_VALIDATION_CONFIG.security.spamPatterns.some(
    (pattern) => pattern.test(content),
  );

  if (hasSpam) {
    throw new yup.ValidationError(
      `Le ${fieldName} contient du contenu non autorisé`,
      value,
      fieldName,
    );
  }

  // Vérifier les tentatives d'injection
  const hasInjection =
    CONTACT_VALIDATION_CONFIG.security.injectionPatterns.some((pattern) =>
      pattern.test(content),
    );

  if (hasInjection) {
    throw new yup.ValidationError(
      `Le ${fieldName} contient du code non autorisé`,
      value,
      fieldName,
    );
  }

  return true;
}

/**
 * Valide qu'un message a du contenu substantiel
 */
function validateSubstantialContent(value) {
  if (!value) return false;

  const message = value.trim();

  // Trop court
  if (message.length < 10) return false;

  // Que des caractères spéciaux ou répétition
  const meaningfulChars = message.replace(/[^a-zA-ZÀ-ÿ0-9]/g, '');
  if (meaningfulChars.length < 5) return false;

  // Vérifier qu'il y a des mots réels (pas que des caractères aléatoires)
  const words = message.split(/\s+/).filter((word) => word.length > 2);
  if (words.length < 2) return false;

  // Détecter les messages générés automatiquement
  const autoGeneratedPatterns = [
    /^.{1,3}$/,
    /^(test|hello|hi|hey)\s*$/i,
    /^[a-z]{20,}$/i, // String random sans espaces
    /^\d+$/,
  ];

  return !autoGeneratedPatterns.some((pattern) => pattern.test(message));
}

// =============================
// SCHÉMA YUP PRINCIPAL
// =============================

export const contactEmailSchema = yup.object({
  name: yup
    .string()
    .required('Le nom est obligatoire')
    .min(
      CONTACT_VALIDATION_CONFIG.name.minLength,
      `Le nom doit contenir au moins ${CONTACT_VALIDATION_CONFIG.name.minLength} caractères`,
    )
    .max(
      CONTACT_VALIDATION_CONFIG.name.maxLength,
      `Le nom ne peut pas dépasser ${CONTACT_VALIDATION_CONFIG.name.maxLength} caractères`,
    )
    .trim()
    .test('real-name', 'Le nom fourni ne semble pas valide', validateRealName)
    .test(
      'content-security',
      'Le nom contient des caractères non autorisés',
      (value) => validateContentSecurity(value, 'nom'),
    ),

  email: yup
    .string()
    .required("L'adresse email est obligatoire")
    .max(
      CONTACT_VALIDATION_CONFIG.email.maxLength,
      `L'email ne peut pas dépasser ${CONTACT_VALIDATION_CONFIG.email.maxLength} caractères`,
    )
    .email("L'adresse email n'est pas valide")
    .lowercase()
    .trim()
    .test(
      'business-email',
      "Cette adresse email n'est pas acceptée",
      validateBusinessEmail,
    ),

  subject: yup
    .string()
    .required('Le sujet est obligatoire')
    .min(
      CONTACT_VALIDATION_CONFIG.subject.minLength,
      `Le sujet doit contenir au moins ${CONTACT_VALIDATION_CONFIG.subject.minLength} caractères`,
    )
    .max(
      CONTACT_VALIDATION_CONFIG.subject.maxLength,
      `Le sujet ne peut pas dépasser ${CONTACT_VALIDATION_CONFIG.subject.maxLength} caractères`,
    )
    .trim()
    .test(
      'content-security',
      'Le sujet contient du contenu non autorisé',
      (value) => validateContentSecurity(value, 'sujet'),
    ),

  message: yup
    .string()
    .required('Le message est obligatoire')
    .min(
      CONTACT_VALIDATION_CONFIG.message.minLength,
      `Le message doit contenir au moins ${CONTACT_VALIDATION_CONFIG.message.minLength} caractères`,
    )
    .max(
      CONTACT_VALIDATION_CONFIG.message.maxLength,
      `Le message ne peut pas dépasser ${CONTACT_VALIDATION_CONFIG.message.maxLength} caractères`,
    )
    .trim()
    .test(
      'substantial-content',
      'Le message doit contenir un contenu plus substantiel',
      validateSubstantialContent,
    )
    .test(
      'content-security',
      'Le message contient du contenu non autorisé',
      (value) => validateContentSecurity(value, 'message'),
    ),
});

// =============================
// FONCTIONS UTILITAIRES
// =============================

/**
 * Prépare les données du FormData pour la validation
 * @param {FormData} formData - Données du formulaire
 * @returns {Object} - Objet formaté pour Yup
 */
export function prepareContactDataFromFormData(formData) {
  // Validation que formData est bien un FormData
  if (!formData || typeof formData.get !== 'function') {
    throw new Error(
      'FormData invalide fourni à prepareContactDataFromFormData',
    );
  }

  const data = {
    name: formData.get('name'),
    email: formData.get('email'),
    subject: formData.get('subject'),
    message: formData.get('message'),
  };

  // Nettoyer les valeurs null/undefined
  Object.keys(data).forEach((key) => {
    if (data[key] === null || data[key] === undefined) {
      data[key] = '';
    } else {
      data[key] = String(data[key]).trim();
    }
  });

  return data;
}

/**
 * Valide les données de contact avec gestion d'erreurs
 * @param {Object} data - Données à valider
 * @returns {Promise<Object>} - Résultat de validation
 */
export async function validateContactEmail(data) {
  try {
    const validatedData = await contactEmailSchema.validate(data, {
      abortEarly: false, // Récupérer toutes les erreurs
      stripUnknown: true, // Supprimer les champs non définis
    });

    return {
      success: true,
      data: validatedData,
      errors: null,
      message: 'Validation réussie',
    };
  } catch (error) {
    if (error.name === 'ValidationError') {
      // Formater les erreurs Yup pour l'affichage
      const formattedErrors = {};

      if (error.inner && error.inner.length > 0) {
        error.inner.forEach((err) => {
          if (err.path) {
            formattedErrors[err.path] = err.message;
          }
        });
      } else {
        // Erreur unique
        formattedErrors[error.path || 'general'] = error.message;
      }

      return {
        success: false,
        data: null,
        errors: formattedErrors,
        message: 'Erreurs de validation détectées',
        errorCount: Object.keys(formattedErrors).length,
      };
    }

    // Erreur inattendue
    return {
      success: false,
      data: null,
      errors: { general: 'Erreur de validation inattendue' },
      message: 'Erreur de validation système',
      originalError:
        process.env.NODE_ENV === 'production' ? undefined : error.message,
    };
  }
}

/**
 * Formate les erreurs de validation pour l'affichage utilisateur
 * @param {Object} errors - Erreurs de validation
 * @returns {string} - Message d'erreur formaté
 */
export function formatContactValidationErrors(errors) {
  if (!errors || Object.keys(errors).length === 0) {
    return 'Erreurs de validation inconnues';
  }

  const errorMessages = Object.entries(errors).map(([field, message]) => {
    const fieldNames = {
      name: 'Nom',
      email: 'Email',
      subject: 'Sujet',
      message: 'Message',
    };

    const fieldName = fieldNames[field] || field;
    return `${fieldName}: ${message}`;
  });

  return errorMessages.join('; ');
}

/**
 * Vérifie si les données semblent provenir d'un bot
 * @param {Object} data - Données à analyser
 * @param {Object} metadata - Métadonnées (temps de remplissage, etc.)
 * @returns {Object} - Résultat de l'analyse
 */
export function detectBotBehavior(data, metadata = {}) {
  const suspiciousIndicators = [];
  let riskScore = 0;

  // Vérifier le temps de remplissage (trop rapide = bot)
  if (metadata.fillTime && metadata.fillTime < 5000) {
    // Moins de 5 secondes
    suspiciousIndicators.push('form_filled_too_quickly');
    riskScore += 3;
  }

  // Vérifier les patterns dans les données
  const allContent =
    `${data.name} ${data.email} ${data.subject} ${data.message}`.toLowerCase();

  // Contenu identique ou très similaire
  if (
    data.name &&
    data.subject &&
    data.name.toLowerCase() === data.subject.toLowerCase()
  ) {
    suspiciousIndicators.push('identical_name_subject');
    riskScore += 2;
  }

  // Utilisation excessive de majuscules
  const uppercaseRatio =
    (allContent.match(/[A-Z]/g) || []).length / allContent.length;
  if (uppercaseRatio > 0.7) {
    suspiciousIndicators.push('excessive_uppercase');
    riskScore += 2;
  }

  // URLs multiples dans le message
  const urlMatches = data.message.match(/http[s]?:\/\/[^\s]+/gi) || [];
  if (urlMatches.length > 2) {
    suspiciousIndicators.push('multiple_urls');
    riskScore += 4;
  }

  // Contenu répétitif
  const words = allContent.split(/\s+/);
  const uniqueWords = new Set(words);
  if (words.length > 20 && uniqueWords.size / words.length < 0.3) {
    suspiciousIndicators.push('repetitive_content');
    riskScore += 3;
  }

  return {
    isSuspicious: riskScore >= 5,
    riskScore,
    indicators: suspiciousIndicators,
    action: riskScore >= 8 ? 'block' : riskScore >= 5 ? 'review' : 'allow',
  };
}

// =============================
// EXPORTS POUR COMPATIBILITÉ
// =============================

// Export par défaut pour utilisation simple
export default {
  schema: contactEmailSchema,
  validate: validateContactEmail,
  prepare: prepareContactDataFromFormData,
  formatErrors: formatContactValidationErrors,
  detectBot: detectBotBehavior,
  config: CONTACT_VALIDATION_CONFIG,
};

// Exports nommés pour flexibilité
export {
  contactEmailSchema as schema,
  validateContactEmail as validate,
  prepareContactDataFromFormData as prepare,
  formatContactValidationErrors as formatErrors,
  detectBotBehavior as detectBot,
  CONTACT_VALIDATION_CONFIG as config,
};
